## 内存管理

### 1. 内存的生命周期

1. **分配**需要的内存
2. **使用**被分配到的内存，读、写操作
3. 不需要使用时将内存**释放**

所有的语言在第二步都是明确的，第一步和第三步在底层的语言是明确的，如`C语言`，但是像`Javascript`  这两部门是隐含的。

`javascript`  在定义变量的时候就完成了内存的分配。如以下几种情况都会自动进行内存的分配：

```javascript
const a = 'string'
const b = []
const c = function(){}
function foo(){}
```
<p style="color:gray;">通过函数调用分配内存</p>

```javascript
const d = new Date()
const e = document.getElementById("#app")
```
### 2. 使用值

使用值得过程就是对内存进行读写的操作，读取与写入可能是一个变量或者一个对象的属性值，或者是传递函数的参数

### 3. 垃圾回收

#### a. 引用计数垃圾收集
```javascript
let obj1 = {
	a:{
		b:'vino'
	}
} //创建了两个对象，都不能被垃圾回收,obj1这个对象记作“obj",引用了a这个对象

const obj2 = obj1 //对象上有两个引用，不能被垃圾回收
obj1 = "koko"  //   对象上只有“obj2”这个引用
let obj3 = obj2.a   //"obj"对象上有了两个引用
obj2 = "vino"  // 目前“obj”这个对象的引用为零，但是“obj”对象的a属性依然被引用，此时还不能垃圾回收
obj3 =null   // 此时“obj” 这个对象上没有引用了可以被垃圾回收
```

<p style="color:gray;">引用计数垃圾回收机制存在的问题：循环引用</p>

```javascript
function foo(){
	let a = {}
	let b = {}
	a.b = b
	b.a = a

	return "vino"
}

foo() // 函数执行完了，理论上讲已经没用了可以被回收，但是由于内部存在了循环引用，导致无法被垃圾回收
```


#### b.  标记-清除算法

>  对象是否可以获得

假定设置了一个 `root`  的根对象(在JavaScript里面是全局对象)。垃圾回收器会定期的从根对象开始查找所有引用的对象，然后再对这些对象进行查找（类似于对树的遍历）。通过这个算法垃圾回收器讲找到所有能获得的对象和收集所有不能查找到的对象。

<p style="color:gray;">缺点：</p>

*  标记-清除算法的一个很大的缺点就是，虽然这些垃圾被清除了，但是剩余的对象的位置是不变的，这会导致闲置的内存不是连续的出现了<i style="color:red">内存碎片</i>。
* 分配速度慢，由于是遍历所有的对象，同时因为碎片化，大对象的分配的速度会更慢